***
**Tracing / Debugging:** `strace`, `ltrace`, `gdb`, `lsof`, `objdump`
***
***
# Strace Command in Linux

## Overview

Strace is a powerful diagnostic, debugging, and instructional utility in Linux used to monitor the system calls used by a program and the signals it receives. It helps in understanding how a program interacts with the operating system, which is essential for troubleshooting, debugging, and performance analysis.

## Installation

To install strace on various Linux distributions, use the following commands:

Debian/Ubuntu:

```
sudo apt update
sudo apt install strace
```

Red Hat/CentOS/Fedora:

```
sudo yum install strace
```

Arch Linux:

```
sudo pacman -S strace
```

## Basic Syntax

```
strace [options] command [command-args]
```

## Commonly Used Options

- `-p <pid>` : Attach strace to an existing process.
    
- `-o <file>` : Write strace output to a file instead of standard error.
    
- `-e <expression>` : Trace only specified system calls, signals, or file operations.
    
- `-f` : Trace child processes created by `fork`, `vfork`, or `clone`.
    
- `-c` : Count time, calls, and errors for each system call.
    
- `-t` : Prefix each line of the trace with the time of day.
    
- `-T` : Show time spent in each system call.
    
- `-s <size>` : Specify the maximum string size to print.
    
- `-h` : Display help information.
    

## Examples

### Example 1: Trace a simple command

Trace the `ls` command:

```
strace ls
```

This will display all system calls made by `ls` along with their return values.

### Example 2: Trace a process by PID

Attach strace to a running process with PID 1234:

```
strace -p 1234
```

This allows monitoring of a process that is already running.

### Example 3: Trace system calls to a file

Trace only file-related system calls for the `cat /etc/passwd` command:

```
strace -e trace=file cat /etc/passwd
```

This filters output to only show file operations.

### Example 4: Save output to a file

Save the strace output of a command to a file for later analysis:

```
strace -o output.txt ls
```

The results will be stored in `output.txt`.

### Example 5: Trace child processes

Trace the `bash` command along with its child processes:

```
strace -f bash -c 'ls; echo Hello'
```

This will trace all commands executed within the bash shell, including forked processes.

### Example 6: Count system call statistics

Get a summary of system call usage for the `ls` command:

```
strace -c ls
```

This will show total calls, errors, and time spent per system call.

### Example 7: Display time of each system call

Trace `ls` and display timestamps:

```
strace -t ls
```

This is useful to understand when each system call occurs.

### Example 8: Show time spent in each system call

```
strace -T ls
```

This displays how long each system call takes, helping in performance analysis.

### Example 9: Limit string output

```
strace -s 50 cat /etc/passwd
```

Limits the printed string to 50 characters to avoid huge outputs.

## Use Cases

- Debugging programs that fail to run or crash.
    
- Understanding the behavior of unknown programs.
    
- Monitoring file and network activity.
    
- Performance analysis by measuring system call time.
    
- Security auditing by tracking system calls.
    

## Tips

- Use `man strace` to get detailed documentation and advanced options.
    
- Combine strace with `grep` to filter specific calls.
    
- Be careful using strace on critical system processes as it can slow them down.
    

* * *

* * *

# Ltrace Command in Linux

## Overview

Ltrace is a diagnostic and debugging utility in Linux that intercepts and records dynamic library calls made by a program along with the system calls it invokes. It is primarily used to analyze how programs interact with shared libraries, which can help in debugging, performance analysis, and security auditing.

## Installation

To install ltrace on various Linux distributions, use the following commands:

Debian/Ubuntu:

```
sudo apt update
sudo apt install ltrace
```

Red Hat/CentOS/Fedora:

```
sudo yum install ltrace
```

Arch Linux:

```
sudo pacman -S ltrace
```

## Basic Syntax

```
ltrace [options] command [command-args]
```

## Commonly Used Options

- `-p <pid>` : Attach ltrace to an existing process.
    
- `-o <file>` : Write ltrace output to a file.
    
- `-e <expression>` : Trace only specified library functions or system calls.
    
- `-f` : Trace child processes.
    
- `-c` : Count calls, errors, and time spent for each function.
    
- `-S <function>` : Trace only calls to specific shared library functions.
    
- `-s <size>` : Specify maximum string size to print.
    
- `-h` : Display help information.
    

## Examples

### Example 1: Trace a simple command

Trace the `ls` command:

```
ltrace ls
```

This will show all library function calls made by `ls` along with system calls.

### Example 2: Attach to a running process

Attach ltrace to a process with PID 1234:

```
ltrace -p 1234
```

This monitors library calls of an existing process.

### Example 3: Trace specific library functions

Trace only `malloc` and `free` calls for a program:

```
ltrace -e malloc+free ./myprogram
```

Useful for memory allocation analysis.

### Example 4: Save output to a file

Save the output of a command to `output.txt`:

```
ltrace -o output.txt ./myprogram
```

The output can be analyzed later.

### Example 5: Trace child processes

Trace a program and all its forked child processes:

```
ltrace -f ./myprogram
```

This ensures that library calls from child processes are also captured.

### Example 6: Count function calls

Get statistics of function calls for a program:

```
ltrace -c ./myprogram
```

Displays total calls, errors, and time spent per library function.

### Example 7: Limit string output

Limit printed string size to 50 characters:

```
ltrace -s 50 ./myprogram
```

Useful for avoiding excessive output from long strings.

### Example 8: Trace specific shared library

Trace calls to functions from the C standard library:

```
ltrace -S libc ./myprogram
```

This filters calls to the specified library only.

## Use Cases

- Debugging programs by monitoring library interactions.
    
- Understanding how a program uses dynamic libraries.
    
- Analyzing memory allocation and deallocation.
    
- Security auditing by tracking library calls.
    
- Performance analysis by measuring time spent in library functions.
    

## Tips

- Use `man ltrace` for detailed documentation.
    
- Combine ltrace with `grep` to filter specific function calls.
    
- Avoid tracing critical system processes as it can slow them down.
    

* * *

* * *

# GDB Command in Linux

## Overview

GDB, the GNU Debugger, is a powerful tool used to debug programs written in C, C++, and other languages. It allows developers to inspect the execution of a program, monitor variables, set breakpoints, and analyze crashes or unexpected behaviors.

## Installation

To install GDB on various Linux distributions, use the following commands:

Debian/Ubuntu:

```
sudo apt update
sudo apt install gdb
```

Red Hat/CentOS/Fedora:

```
sudo yum install gdb
```

Arch Linux:

```
sudo pacman -S gdb
```

## Basic Syntax

```
gdb [options] [program] [core-file or PID]
```

## Commonly Used Options

- `-p <pid>` : Attach GDB to a running process.
    
- `-tui` : Launch GDB in TUI (Text User Interface) mode.
    
- `-ex <command>` : Execute a GDB command upon startup.
    
- `-batch` : Run GDB in batch mode without interactive prompts.
    
- `--args` : Specify program arguments after the options.
    
- `-h` : Display help information.
    

## Common Commands in GDB

### Program Control

- `run [args]` : Start the program with optional arguments.
    
- `continue` : Resume execution after a breakpoint or stop.
    
- `step` : Execute the next line of code, stepping into functions.
    
- `next` : Execute the next line of code, without stepping into functions.
    
- `finish` : Continue execution until the current function returns.
    
- `kill` : Stop the program being debugged.
    

### Breakpoints and Watchpoints

- `break <line|function>` : Set a breakpoint at a specific line or function.
    
- `delete [breakpoint_number]` : Remove a breakpoint.
    
- `info breakpoints` : List all breakpoints.
    
- `watch <variable>` : Pause execution when a variable changes.
    
- `disable <breakpoint_number>` : Temporarily disable a breakpoint.
    
- `enable <breakpoint_number>` : Enable a disabled breakpoint.
    

### Inspecting Variables and Memory

- `print <variable>` : Display the value of a variable.
    
- `display <variable>` : Automatically display a variable's value each step.
    
- `set var <variable> = <value>` : Modify a variable's value.
    
- `x/<format> <address>` : Examine memory at a specific address.
    
- `info locals` : Show local variables in the current function.
    

### Stack and Functions

- `backtrace` or `bt` : Display the call stack.
    
- `frame <number>` : Switch to a specific stack frame.
    
- `up` : Move up one level in the call stack.
    
- `down` : Move down one level in the call stack.
    

### Miscellaneous

- `list` : Display source code around the current line.
    
- `info registers` : Show CPU registers.
    
- `help` : Show GDB commands and usage.
    

## Examples

### Example 1: Debug a program

```
gdb ./myprogram
```

Starts debugging the program `myprogram` interactively.

### Example 2: Set a breakpoint and run

```
gdb ./myprogram
break main
run
```

Sets a breakpoint at the `main` function and starts execution.

### Example 3: Step through code

```
gdb ./myprogram
break main
run
step
next
```

Executes code line by line, stepping into functions with `step` and skipping with `next`.

### Example 4: Inspect variables

```
print myVariable
display myVariable
set var myVariable = 10
```

Prints the value of a variable, automatically displays it each step, and modifies its value.

### Example 5: View call stack

```
backtrace
frame 2
up
down
```

Shows the function call stack and navigates through stack frames.

### Example 6: Attach to a running process

```
gdb -p 1234
```

Attach GDB to the process with PID 1234 for live debugging.

### Example 7: Examine memory

```
x/10xw &myArray
```

Displays 10 words from the memory address of `myArray` in hexadecimal.

### Example 8: Debug with program arguments

```
gdb --args ./myprogram arg1 arg2
run
```

Passes command-line arguments to the program while debugging.

## Use Cases

- Debugging runtime errors, segmentation faults, and crashes.
    
- Monitoring program flow and logic.
    
- Inspecting variable states and memory usage.
    
- Performance analysis and function profiling.
    
- Educational purposes for learning program behavior.
    

## Tips

- Compile programs with the `-g` flag to include debug information.
    
- Use TUI mode for a visual representation of code and breakpoints.
    
- Combine GDB with core dumps for post-mortem analysis.
    
- Use `set pagination off` to avoid pausing output for long commands.
    

* * *

* * *

# Lsof Command in Linux

## Overview

Lsof (List Open Files) is a powerful utility in Linux used to display information about files opened by processes. In Unix-like operating systems, everything is treated as a file, including regular files, directories, network sockets, and devices. Lsof is commonly used for system monitoring, troubleshooting, and network analysis.

## Installation

To install lsof on various Linux distributions, use the following commands:

Debian/Ubuntu:

```
sudo apt update
sudo apt install lsof
```

Red Hat/CentOS/Fedora:

```
sudo yum install lsof
```

Arch Linux:

```
sudo pacman -S lsof
```

## Basic Syntax

```
lsof [options] [file|command]
```

## Commonly Used Options

- `-p <pid>` : Show files opened by a specific process ID.
    
- `-u <user>` : List files opened by a specific user.
    
- `-i` : List network files and connections.
    
- `-i :<port>` : List processes using a specific port.
    
- `-c <command>` : List files opened by a specific command.
    
- `+D <directory>` : List all files opened under a directory.
    
- `+d <directory>` : List files opened directly in a directory (non-recursive).
    
- `-n` : Disable host name resolution (speeds up network queries).
    
- `-P` : Disable port name resolution.
    
- `-t` : Output only process IDs.
    
- `-h` : Display help information.
    

## Examples

### Example 1: List all open files

```
lsof
```

Displays all open files on the system along with associated processes.

### Example 2: List files opened by a specific process

```
lsof -p 1234
```

Shows all files opened by the process with PID 1234.

### Example 3: List files opened by a specific user

```
lsof -u sushil
```

Displays all files opened by the user `sushil`.

### Example 4: List files opened by a specific command

```
lsof -c ssh
```

Shows files opened by processes running the `ssh` command.

### Example 5: List network connections

```
lsof -i
```

Displays all network files and open connections.

### Example 6: Check which process is using a port

```
lsof -i :80
```

Finds the process using port 80, useful for troubleshooting web server conflicts.

### Example 7: List open files in a directory recursively

```
lsof +D /var/log
```

Lists all files opened under `/var/log` including subdirectories.

### Example 8: List open files in a directory non-recursively

```
lsof +d /var/log
```

Lists files opened directly in `/var/log` without descending into subdirectories.

### Example 9: List process IDs only

```
lsof -t -i :22
```

Displays only the PIDs of processes using port 22, useful for scripting.

### Example 10: Disable name resolution for faster output

```
lsof -nP -i
```

Disables host and port name resolution, improving performance on systems with many connections.

## Use Cases

- Identify which processes are using specific files or directories.
    
- Troubleshoot port conflicts and network connections.
    
- Monitor system activity and open files for performance analysis.
    
- Detect unauthorized access to files or network resources.
    
- Use in scripts to automate system monitoring tasks.
    

## Tips

- Combine lsof with `grep` to filter specific files, processes, or users.
    
- Use `lsof -r <seconds>` to repeat output at intervals for continuous monitoring.
    
- Avoid using lsof on heavily loaded systems without proper filters as it may generate large output.
    

* * *

* * *

# Objdump Command in Linux

## Overview

Objdump is a versatile command-line tool used to display information about object files, executables, and libraries in Linux. It is commonly used for reverse engineering, debugging, and analyzing compiled binaries. Objdump can show assembly code, headers, symbol tables, and sections of binaries.

## Installation

To install objdump on various Linux distributions, use the following commands:

Debian/Ubuntu:

```
sudo apt update
sudo apt install binutils
```

Red Hat/CentOS/Fedora:

```
sudo yum install binutils
```

Arch Linux:

```
sudo pacman -S binutils
```

## Basic Syntax

```
objdump [options] file
```

## Commonly Used Options

- `-d` : Disassemble all sections of the binary.
    
- `-D` : Disassemble all sections, including data sections.
    
- `-s` : Display full contents of all sections in hexadecimal and ASCII.
    
- `-h` : Display section headers.
    
- `-f` : Display file headers.
    
- `-t` : Display the symbol table.
    
- `-x` : Display all available header information.
    
- `-S` : Display source code intermixed with assembly (requires debug symbols).
    
- `-r` : Display relocation entries.
    
- `-j <section>` : Display information only for the specified section.
    
- `-C` : Demangle C++ symbol names.
    
- `-M <modifier>` : Use architecture-specific disassembly modifiers.
    

## Examples

### Example 1: Disassemble a binary

```
objdump -d ./myprogram
```

Shows the assembly instructions of the program.

### Example 2: Display all sections in hexadecimal

```
objdump -s ./myprogram
```

Displays the content of all sections in both hexadecimal and ASCII formats.

### Example 3: Show section headers

```
objdump -h ./myprogram
```

Lists all sections of the binary along with their size, offset, and memory address.

### Example 4: Show file headers

```
objdump -f ./myprogram
```

Displays basic information about the file such as architecture, entry point, and flags.

### Example 5: Display symbol table

```
objdump -t ./myprogram
```

Shows all symbols defined in the binary, including functions and variables.

### Example 6: Disassemble with source code

```
objdump -S ./myprogram
```

Displays assembly code intermixed with source code if debug symbols are available.

### Example 7: Display relocation entries

```
objdump -r ./myprogram
```

Lists all relocation entries in the binary.

### Example 8: Display information for a specific section

```
objdump -j .text -d ./myprogram
```

Disassembles only the `.text` section of the binary.

### Example 9: Display all headers

```
objdump -x ./myprogram
```

Shows all available header information, including section headers, symbol table, and relocation info.

### Example 10: Demangle C++ symbols

```
objdump -C -t ./myprogram
```

Displays the symbol table with human-readable C++ names.

## Use Cases

- Reverse engineering binaries for analysis or debugging.
    
- Inspecting compiled executables to verify compiler output.
    
- Analyzing sections, symbols, and relocation information.
    
- Debugging low-level issues in programs.
    
- Educational purposes to learn assembly and binary structures.
    

## Tips

- Use `man objdump` for detailed documentation and advanced options.
    
- Combine objdump with `grep` to filter specific symbols or instructions.
    
- Use binaries compiled with debug symbols to get source code alongside assembly with `-S`.
    
- Be careful analyzing stripped binaries, as symbol information may be missing.
    

&nbsp;
