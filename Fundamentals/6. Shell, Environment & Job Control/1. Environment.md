* * *

**Environment:** `env`, `export`, `printenv`, `set`, `unset`, `declare`, `typeset`

* * *

* * *

# `env` Command in Linux

The `env` command is used to **display, modify, and run commands with environment variables**. It is commonly used in shell scripting, debugging, and configuring application behavior without permanently changing the system environment.

* * *

## 1\. What Are Environment Variables?

Environment variables are **key=value pairs** that affect how processes behave.

Examples:

- `PATH` – where the shell looks for executables
    
- `HOME` – user's home directory
    
- `USER` – current username
    
- `SHELL` – default shell
    

They are inherited by child processes.

* * *

## 2\. Basic Syntax

```bash
env [OPTION]... [-] [NAME=VALUE]... [COMMAND [ARG]...]
```

* * *

## 3\. Display Environment Variables

### Show all environment variables

```bash
env
```

or

```bash
printenv
```

* * *

### Show a specific variable

```bash
env | grep PATH
```

or

```bash
printenv PATH
```

* * *

## 4\. Set an Environment Variable Temporarily

Environment variables set using `env` exist **only for the command being run**.

```bash
env VAR=value command
```

### Example

```bash
env DEBUG=true python app.py
```

`DEBUG` is available only inside `app.py`.

* * *

## 5\. Run a Command with Modified Environment

### Set multiple variables

```bash
env VAR1=value1 VAR2=value2 command
```

### Example

```bash
env NODE_ENV=production PORT=8080 node server.js
```

* * *

## 6\. Remove (Unset) an Environment Variable

### Using `-u`

```bash
env -u VAR command
```

### Example

```bash
env -u PATH bash
```

This runs `bash` **without PATH** (dangerous but useful for testing).

* * *

## 7\. Start with an Empty Environment

### Using `-i` (ignore environment)

```bash
env -i command
```

### Example

```bash
env -i bash
```

This starts a shell with **no inherited variables**.

* * *

### Empty environment + custom variables

```bash
env -i HOME=/tmp USER=test bash
```

* * *

## 8\. Use `env` in Shebang (`#!`)

This is **one of the most important uses** of `env`.

### Problem

Hardcoding interpreter paths is unreliable:

```bash
#!/usr/bin/python3
```

### Solution

```bash
#!/usr/bin/env python3
```

The system searches `PATH` to find `python3`.

### Common Shebang Examples

```bash
#!/usr/bin/env bash
#!/usr/bin/env node
#!/usr/bin/env python
#!/usr/bin/env perl
```

* * *

## 9\. `env` vs `export`

| Feature | `env` | `export` |
| --- | --- | --- |
| Scope | Single command | Current shell & children |
| Persistence | Temporary | Until shell exits |
| Use in scripts | Yes | Yes |
| Modifies shell | No  | Yes |

### Example

```bash
export VAR=123
```

vs

```bash
env VAR=123 command
```

* * *

## 10\. Practical Examples

### Debug a program

```bash
env DEBUG=1 ./my_program
```

* * *

### Run command with custom PATH

```bash
env PATH=/opt/bin:$PATH mytool
```

* * *

### Test program without HOME

```bash
env -u HOME ./script.sh
```

* * *

### Run command in a clean environment

```bash
env -i /bin/bash --noprofile --norc
```

* * *

## 11\. Combine `env` with `sudo`

### Preserve variables

```bash
sudo env VAR=value command
```

### Example

```bash
sudo env PATH=$PATH my_admin_script
```

* * *

## 12\. Commonly Used Environment Variables

| Variable | Description |
| --- | --- |
| `PATH` | Executable search path |
| `HOME` | Home directory |
| `USER` | Username |
| `SHELL` | Default shell |
| `PWD` | Current directory |
| `LANG` | Language / locale |
| `EDITOR` | Default editor |

* * *

## 13\. Security Notes

- Never trust environment variables in **setuid programs**
    
- `PATH` manipulation can lead to **command hijacking**
    
- Use full paths in security-sensitive scripts
    

* * *

## 14\. Useful One‑Liners

```bash
env | sort
```

```bash
env | wc -l
```

```bash
env -i env
```

* * *

## 15\. Summary

- `env` displays environment variables
    
- Temporarily sets variables for commands
    
- Removes variables using `-u`
    
- Clears environment using `-i`
    
- Essential for portable shebangs
    
- Extremely useful for testing and debugging
    

* * *

* * *

# `printenv` Command in Linux

The `printenv` command is used to **display environment variables** in Linux. It is simple, safe, and commonly used in scripting, debugging, and inspecting the runtime environment of processes.

Unlike `export`, `printenv` **does not modify variables** — it only reads and prints them.

* * *

## 1\. What Are Environment Variables?

Environment variables are **key=value pairs** passed from a parent process to its child processes.

Common examples:

- `PATH`
    
- `HOME`
    
- `USER`
    
- `SHELL`
    
- `LANG`
    

They influence how programs behave.

* * *

## 2\. What Does `printenv` Do?

- Prints **all environment variables** or selected ones
    
- Reads only **exported variables**
    
- Does **not** print shell-only variables
    
- Does **not** modify the environment
    

* * *

## 3\. Basic Syntax

```bash
printenv [OPTION]... [VARIABLE]...
```

* * *

## 4\. Print All Environment Variables

```bash
printenv
```

Equivalent to:

```bash
env
```

* * *

## 5\. Print a Specific Environment Variable

```bash
printenv PATH
```

```bash
printenv HOME
```

If the variable does not exist, **nothing is printed** and exit status is non‑zero.

* * *

## 6\. Print Multiple Variables

```bash
printenv USER HOME SHELL
```

* * *

## 7\. `printenv` vs Shell Expansion

### Using `echo`

```bash
echo $PATH
```

### Using `printenv`

```bash
printenv PATH
```

**Difference:**

- `echo $VAR` expands via the shell
    
- `printenv VAR` queries the environment directly
    

* * *

## 8\. `printenv` vs `env`

| Feature | `printenv` | `env` |
| --- | --- | --- |
| Purpose | Display variables | Display / run commands |
| Modify env | ❌ No | ✅ Yes |
| Run command | ❌ No | ✅ Yes |
| POSIX | ✅ Yes | ✅ Yes |

* * *

## 9\. Exit Status Behavior

```bash
printenv PATH
echo $?
```

- `0` → variable exists
    
- `1` → variable does not exist
    

Useful in scripts.

* * *

## 10\. Use `printenv` in Shell Scripts

```bash
#!/usr/bin/env bash
printenv DB_HOST
```

### Conditional check

```bash
if printenv DB_HOST > /dev/null; then
  echo "DB_HOST is set"
else
  echo "DB_HOST is not set"
fi
```

* * *

## 11\. Print Environment of a Command

```bash
printenv | grep PATH
```

* * *

## 12\. `printenv` vs `set` vs `export`

| Command | Shows shell vars | Shows env vars | Modifies env |
| --- | --- | --- | --- |
| `set` | ✅ Yes | ✅ Yes | ❌ No |
| `export -p` | ❌ No | ✅ Yes | ✅ Yes |
| `printenv` | ❌ No | ✅ Yes | ❌ No |

* * *

## 13\. Common Environment Variables to Inspect

| Variable | Description |
| --- | --- |
| `PATH` | Executable search path |
| `HOME` | Home directory |
| `USER` | Username |
| `PWD` | Current directory |
| `SHELL` | Default shell |
| `LANG` | Locale |
| `EDITOR` | Default editor |

* * *

## 14\. `printenv` with `sudo`

```bash
sudo printenv
```

⚠️ By default, `sudo` **cleans most variables**.

### Preserve variables

```bash
sudo -E printenv
```

* * *

## 15\. Debugging Use Cases

### Check if variable is exported

```bash
printenv MY_VAR
```

### Compare environments

```bash
printenv | sort
```

* * *

## 16\. Filtering Output

```bash
printenv | grep JAVA
```

```bash
printenv | awk -F= '{print $1}'
```

* * *

## 17\. POSIX and Portability

- `printenv` is POSIX‑compliant
    
- Available on Linux, BSD, macOS
    
- Preferred over `env | grep` in scripts
    

* * *

## 18\. Common Mistakes

❌ Expecting shell variables to appear

```bash
VAR=123
printenv VAR   # nothing
```

✔ Correct

```bash
export VAR=123
printenv VAR
```

* * *

## 19\. Security Notes

- Avoid printing secrets in logs
    
- Environment variables may leak via `printenv`
    
- Be cautious in multi‑user systems
    

* * *

## 20\. Useful One‑Liners

```bash
printenv | wc -l
```

```bash
printenv | sort
```

```bash
printenv PATH HOME USER
```

* * *

## 21\. Summary

- `printenv` prints **only environment variables**
    
- Does not modify the environment
    
- Safer and simpler than `env` for inspection
    
- Ideal for scripts and debugging
    

* * *

* * *

# `export` Command in Linux 

The `export` command is used to **set environment variables and make them available to child processes**. It is a **shell builtin** (not a standalone binary) and is fundamental to Linux shell usage, scripting, and process management.

* * *

## 1\. What Does `export` Do?

- Marks a variable to be **inherited by child processes**
    
- Converts a shell variable into an **environment variable**
    
- Persists for the **current shell session** and all subprocesses
    

Without `export`, variables exist **only in the current shell**.

* * *

## 2\. Basic Syntax

```bash
export NAME=value
export NAME
export NAME1 NAME2
export -p
```

* * *

## 3\. Shell Variable vs Environment Variable

### Shell variable (not exported)

```bash
VAR=hello
bash
echo $VAR   # empty
```

### Exported variable

```bash
export VAR=hello
bash
echo $VAR   # hello
```

* * *

## 4\. Creating and Exporting Variables

### Create and export in one step

```bash
export APP_ENV=production
```

### Export an existing variable

```bash
APP_ENV=production
export APP_ENV
```

* * *

## 5\. Export Multiple Variables

```bash
export VAR1 VAR2 VAR3
```

Or:

```bash
export VAR1=value1 VAR2=value2
```

* * *

## 6\. View Exported Variables

### Show all exported variables

```bash
export -p
```

Equivalent to:

```bash
declare -x
```

* * *

### Check a specific variable

```bash
echo $PATH
```

* * *

## 7\. Export and Subshell Behavior

Exported variables are inherited by **child shells**, but **not parent shells**.

```bash
export VAR=123
bash
echo $VAR   # 123
exit
echo $VAR   # 123
```

But:

```bash
bash
export VAR=456
exit
echo $VAR   # empty
```

* * *

## 8\. Unexport (Remove) Variables

### Remove variable entirely

```bash
unset VAR
```

### Remove export flag but keep variable (bash)

```bash
export VAR=hello
export -n VAR
```

* * *

## 9\. Exporting PATH Correctly

### Append to PATH (recommended)

```bash
export PATH="$PATH:/opt/myapp/bin"
```

### Prepend to PATH

```bash
export PATH="/opt/myapp/bin:$PATH"
```

⚠️ Never overwrite PATH blindly.

* * *

## 10\. Export in Shell Scripts

```bash
#!/usr/bin/env bash
export DB_HOST=localhost
export DB_PORT=5432
./child_script.sh
```

`child_script.sh` can access these variables.

* * *

## 11\. Export vs `env`

| Feature | `export` | `env` |
| --- | --- | --- |
| Type | Shell builtin | External command |
| Scope | Current shell & children | Single command |
| Persistence | Until shell exits | Temporary |
| Modifies shell | Yes | No  |

### Example

```bash
export DEBUG=1
./app
```

vs

```bash
env DEBUG=1 ./app
```

* * *

## 12\. Export in Startup Files

### Temporary (current session)

```bash
export VAR=value
```

### Persistent (recommended locations)

| File | Scope |
| --- | --- |
| `~/.bashrc` | Interactive shells |
| `~/.bash_profile` | Login shells |
| `~/.profile` | POSIX shells |
| `/etc/environment` | System-wide |

Example:

```bash
export JAVA_HOME=/usr/lib/jvm/java-17
```

* * *

## 13\. Exporting Functions (Bash)

```bash
myfunc() { echo hello; }
export -f myfunc
bash
myfunc
```

⚠️ Rarely used; security risk in old Bash versions.

* * *

## 14\. Common Exported Variables

| Variable | Purpose |
| --- | --- |
| `PATH` | Command lookup path |
| `HOME` | Home directory |
| `LANG` | Locale |
| `EDITOR` | Default editor |
| `JAVA_HOME` | Java installation |
| `PYTHONPATH` | Python modules |
| `LD_LIBRARY_PATH` | Shared libraries |

* * *

## 15\. Common Mistakes

❌ Spaces around `=`

```bash
export VAR = value
```

❌ Overwriting PATH

```bash
export PATH=/my/bin
```

❌ Expecting parent shell to see exports

* * *

## 16\. Security Considerations

- Avoid exporting secrets in shell history
    
- Do not export untrusted input
    
- `LD_LIBRARY_PATH` and `PATH` can be exploited
    
- Never rely on exported variables in setuid programs
    

* * *

## 17\. Debugging Tips

```bash
export | grep VAR
```

```bash
env | grep VAR
```

```bash
set | grep VAR
```

* * *

## 18\. Useful One-Liners

```bash
export $(cat .env | xargs)
```

```bash
export PATH="$PATH:$(pwd)/bin"
```

```bash
unset $(env | cut -d= -f1)
```

* * *

## 19\. POSIX Notes

- `export` is POSIX-compliant
    
- `export -n` and `export -f` are Bash extensions
    

* * *

## 20\. Summary

- `export` makes variables available to child processes
    
- Variables persist for the shell session
    
- Essential for scripting and configuration
    
- Prefer appending/prepending PATH
    
- Use startup files for permanence
    

* * *

* * *

# `set` Command in Linux

The `set` command is a **shell builtin** used to **control shell behavior, manage positional parameters, display variables, and enable/disable shell options**. It is one of the most powerful and commonly misunderstood commands in Linux shells (especially `bash`).

* * *

## 1\. What Does `set` Do?

Depending on how it is used, `set` can:

- Display **all shell variables and functions**
    
- Enable or disable **shell options** (like `-e`, `-x`)
    
- Set **positional parameters** (`$1`, `$2`, ...)
    
- Control **error handling and debugging** behavior
    

It directly affects the **current shell**.

* * *

## 2\. Basic Syntax

```bash
set [options] [--] [arg ...]
```

* * *

## 3\. Display All Shell Variables

```bash
set
```

This prints:

- Shell variables
    
- Environment variables
    
- Shell functions
    

⚠️ Output is usually very long.

* * *

## 4\. `set` vs `env` vs `printenv`

| Command | Shell vars | Env vars | Modifies shell |
| --- | --- | --- | --- |
| `set` | ✅ Yes | ✅ Yes | ✅ Yes |
| `env` | ❌ No | ✅ Yes | ❌ No |
| `printenv` | ❌ No | ✅ Yes | ❌ No |

* * *

## 5\. Positional Parameters with `set`

### Set positional parameters

```bash
set one two three
```

Now:

```bash
echo $1  # one
echo $2  # two
echo $3  # three
echo $#  # 3
```

* * *

### Reset positional parameters

```bash
set --
```

* * *

### Use in scripts

```bash
set -- "$@" extra_arg
```

* * *

## 6\. Important Shell Options

### `set -e` (Exit on error)

```bash
set -e
false
echo "This will not run"
```

* * *

### `set -u` (Treat unset variables as error)

```bash
set -u
echo $UNDEFINED_VAR
```

* * *

### `set -x` (Debug / trace execution)

```bash
set -x
echo hello
```

Output shows executed commands.

* * *

### `set -o pipefail`

```bash
set -o pipefail
false | true
echo $?  # non-zero
```

* * *

## 7\. Disable Options

Use `+` instead of `-`.

```bash
set +e
set +x
```

* * *

## 8\. Commonly Used Options Summary

| Option | Meaning |
| --- | --- |
| `-e` | Exit on error |
| `-u` | Error on unset vars |
| `-x` | Debug trace |
| `-v` | Print shell input |
| `-f` | Disable globbing |
| `-C` | Prevent file overwrite |
| `-o pipefail` | Pipeline failure detection |

* * *

## 9\. Safe Bash Script Mode

```bash
set -euo pipefail
```

This is a **best practice** for production scripts.

* * *

## 10\. `set --` vs `shift`

```bash
set -- a b c
shift
echo $1  # b
```

* * *

## 11\. Handling Script Arguments

```bash
while [ $# -gt 0 ]; do
  echo "$1"
  shift
done
```

* * *

## 12\. Globbing Control

### Disable filename expansion

```bash
set -f
echo *
```

### Re-enable globbing

```bash
set +f
```

* * *

## 13\. Prevent File Overwrites

```bash
set -C
echo test > file.txt  # fails if file exists
```

* * *

## 14\. `set -o` Long Options

```bash
set -o
```

Enable:

```bash
set -o errexit
set -o nounset
set -o xtrace
```

Disable:

```bash
set +o errexit
```

* * *

## 15\. Script Debugging Example

```bash
#!/usr/bin/env bash
set -x
set -e
cp file1 file2
rm missing_file
```

* * *

## 16\. Common Mistakes

❌ Using `set -e` blindly

❌ Forgetting `set +x`

❌ Expecting `set` to persist across shells

* * *

## 17\. POSIX Notes

- `set` is POSIX-compliant
    
- Some options (`pipefail`) are Bash-specific
    

* * *

## 18\. Security Considerations

- `set -x` may leak secrets
    
- Be cautious when echoing variables
    
- Avoid exposing sensitive arguments
    

* * *

## 19\. Useful One-Liners

```bash
set -o | grep pipefail
```

```bash
(set -x; command)
```

```bash
set -- "$@"
```

* * *

## 20\. Summary

- `set` controls shell behavior
    
- Manages positional parameters
    
- Enables strict & debug modes
    
- Essential for robust shell scripting
    
- Acts only on the current shell
    

* * *

* * *

# `unset` Command in Linux

The `unset` command is a **shell builtin** used to **remove variables and functions** from the current shell environment. It is essential for variable management, cleanup, debugging, and secure scripting.

* * *

## 1\. What Does `unset` Do?

Depending on usage, `unset` can:

- Remove **shell variables**
    
- Remove **environment variables**
    
- Remove **exported variables**
    
- Remove **shell functions**
    

Once unset, the variable or function **no longer exists** in the current shell.

* * *

## 2\. Basic Syntax

```bash
unset [OPTION] NAME...
```

* * *

## 3\. Unset a Shell Variable

```bash
VAR=hello
unset VAR
echo $VAR   # empty
```

* * *

## 4\. Unset an Environment Variable

```bash
export VAR=hello
unset VAR
printenv VAR   # nothing
```

This removes the variable completely.

* * *

## 5\. Unset Multiple Variables

```bash
unset VAR1 VAR2 VAR3
```

* * *

## 6\. Unset Exported vs Non-Exported Variables

`unset` works the same for both:

```bash
VAR1=one
export VAR2=two
unset VAR1 VAR2
```

Both are removed from the shell.

* * *

## 7\. Unset Functions

### Define a function

```bash
myfunc() { echo hello; }
```

### Remove the function

```bash
unset -f myfunc
```

* * *

## 8\. Unset Variables Safely

### Check before unsetting

```bash
if [ -n "${VAR+x}" ]; then
  unset VAR
fi
```

* * *

## 9\. `unset` vs `export -n`

| Command | Result |
| --- | --- |
| `unset VAR` | Removes variable entirely |
| `export -n VAR` | Keeps variable, removes export |

### Example

```bash
export VAR=hello
export -n VAR
echo $VAR        # hello
printenv VAR     # empty
```

* * *

## 10\. `unset` vs `set`

| Command | Purpose |
| --- | --- |
| `set VAR=value` | Create or modify variable |
| `unset VAR` | Remove variable |

* * *

## 11\. Unset Positional Parameters

### Remove all positional parameters

```bash
set -- a b c
unset "$@"
```

⚠️ This is rarely recommended.

### Proper way

```bash
set --
```

* * *

## 12\. Unset Special Variables (Limitations)

Some variables **cannot be unset** or behave specially:

| Variable | Behavior |
| --- | --- |
| `PATH` | Can be unset but dangerous |
| `HOME` | Can be unset |
| `PWD` | Read-only |
| `UID` | Read-only |
| `RANDOM` | Special |

Example:

```bash
unset UID   # fails
```

* * *

## 13\. Unset Read-Only Variables

```bash
readonly VAR=123
unset VAR   # error
```

* * *

## 14\. Use `unset` in Shell Scripts

```bash
#!/usr/bin/env bash
SECRET=token
unset SECRET
```

Useful for cleaning up sensitive data.

* * *

## 15\. `unset` with Arrays (Bash)

### Unset entire array

```bash
arr=(a b c)
unset arr
```

### Unset specific element

```bash
unset 'arr[1]'
```

* * *

## 16\. `unset` with Associative Arrays

```bash
declare -A map
map[key]=value
unset 'map[key]'
```

* * *

## 17\. Exit Status

```bash
unset VAR
echo $?
```

- `0` → success
    
- `non-zero` → failure (readonly, invalid)
    

* * *

## 18\. Common Mistakes

❌ Unsetting PATH accidentally

```bash
unset PATH
```

❌ Assuming unset affects parent shell

❌ Trying to unset readonly variables

* * *

## 19\. Security Considerations

- Always `unset` secrets after use
    
- Avoid leaking credentials in debug output
    
- Use subshells for isolation
    

* * *

## 20\. Useful One-Liners

```bash
unset HISTFILE
```

```bash
unset $(env | cut -d= -f1)
```

```bash
unset -f myfunc
```

* * *

## 21\. POSIX Notes

- `unset` is POSIX-compliant
    
- `unset -f` is POSIX
    
- Array behavior is Bash-specific
    

* * *

## 22\. Summary

- `unset` removes variables and functions
    
- Works on shell and environment variables
    
- Cannot remove readonly variables
    
- Important for cleanup and security
    
- Affects only the current shell
    

* * *

* * *

# `declare` Command in Linux

The `declare` command is a **Bash builtin** used to **define variables, set attributes, declare arrays, control variable scope, and inspect variable properties**. It is essential for advanced Bash scripting and is closely related to `typeset`.

* * *

## 1\. What Does `declare` Do?

Depending on options, `declare` can:

- Create shell variables
    
- Set variable attributes (readonly, integer, lowercase, etc.)
    
- Declare indexed and associative arrays
    
- Control variable scope (`local` behavior)
    
- Display variable definitions and attributes
    

It affects **only the current shell or function scope**.

* * *

## 2\. Basic Syntax

```bash
declare [OPTION] NAME[=VALUE]...
```

* * *

## 3\. `declare` vs `set` vs `export`

| Command | Create vars | Attributes | Export env |
| --- | --- | --- | --- |
| `declare` | ✅ Yes | ✅ Yes | ❌ No |
| `set` | ✅ Yes | ❌ No | ❌ No |
| `export` | ✅ Yes | ❌ No | ✅ Yes |

* * *

## 4\. Declare a Simple Variable

```bash
declare VAR=hello
echo $VAR
```

Equivalent to:

```bash
VAR=hello
```

* * *

## 5\. Declare Read-Only Variables

```bash
declare -r CONST=100
```

Attempting to modify it:

```bash
CONST=200   # error
```

* * *

## 6\. Declare Integer Variables

```bash
declare -i COUNT=5
COUNT=COUNT+3
echo $COUNT   # 8
```

Arithmetic is evaluated automatically.

* * *

## 7\. Declare Lowercase / Uppercase Variables

### Force lowercase

```bash
declare -l name="HELLO"
echo $name   # hello
```

### Force uppercase

```bash
declare -u city="kathmandu"
echo $city   # KATHMANDU
```

* * *

## 8\. Declare Indexed Arrays

```bash
declare -a arr
arr=(one two three)
echo ${arr[1]}   # two
```

* * *

## 9\. Declare Associative Arrays (Key–Value)

```bash
declare -A map
map[name]=Sushil
map[role]=admin

echo ${map[name]}
```

Bash 4+ required.

* * *

## 10\. Declare Local Variables (Functions)

```bash
myfunc() {
  declare local_var=inside
  echo $local_var
}

myfunc
echo $local_var   # empty
```

Equivalent to `local`.

* * *

## 11\. Declare Exported Variables

```bash
declare -x VAR=hello
```

Equivalent to:

```bash
export VAR=hello
```

* * *

## 12\. Display Variables with `declare`

### Show all variables

```bash
declare
```

### Show exported variables

```bash
declare -x
```

### Show functions

```bash
declare -f
```

### Show a specific variable

```bash
declare VAR
```

* * *

## 13\. Inspect Variable Attributes

```bash
declare -p VAR
```

Example output:

```bash
declare -x VAR="hello"
```

* * *

## 14\. Common `declare` Options

| Option | Meaning |
| --- | --- |
| `-a` | Indexed array |
| `-A` | Associative array |
| `-i` | Integer |
| `-r` | Read-only |
| `-x` | Export |
| `-l` | Lowercase |
| `-u` | Uppercase |
| `-f` | Functions |
| `-p` | Print attributes |

* * *

## 15\. Using `declare` in Scripts

```bash
#!/usr/bin/env bash
declare -r APP_NAME="myapp"
declare -i RETRIES=3
```

* * *

## 16\. `declare` vs `local`

| Feature | `declare` | `local` |
| --- | --- | --- |
| Global vars | ✅ Yes | ❌ No |
| Function scope | ✅ Yes | ✅ Yes |
| Attributes | ✅ Yes | ❌ No |

* * *

## 17\. `declare` vs `typeset`

- `typeset` is a synonym in Bash
    
- `declare` is more commonly used in scripts
    

```bash
typeset VAR=hello
```

* * *

## 18\. Common Mistakes

❌ Using `declare` in `/bin/sh` (not supported)

❌ Assuming `declare` exports by default

❌ Using associative arrays in Bash < 4

* * *

## 19\. Security Considerations

- Avoid printing sensitive variables
    
- `declare -x` exposes vars to child processes
    
- Read-only vars prevent accidental overwrite
    

* * *

## 20\. Useful One-Liners

```bash
declare -p | grep PATH
```

```bash
declare -a files=(*)
```

```bash
declare -i sum=0
```

* * *

## 21\. POSIX Notes

- `declare` is **not POSIX**
    
- Bash-specific (and some ksh/zsh support)
    
- Use `export`/`set` for POSIX scripts
    

* * *

## 22\. Summary

- `declare` is the most powerful variable tool in Bash
    
- Supports attributes, arrays, and scope control
    
- Ideal for advanced scripting
    
- Not portable to POSIX `sh`
    

* * *

* * *

# `typeset` Command in Linux 

The `typeset` command is a **shell builtin** used to **declare variables, assign attributes, define arrays, control scope, and inspect variables**. In **Bash**, `typeset` is largely a **synonym of `declare`**, while in other shells (like `ksh` and `zsh`) it plays a more central role.

* * *

## 1\. What Does `typeset` Do?

Depending on the shell and options used, `typeset` can:

- Create shell variables
    
- Assign variable attributes (readonly, integer, uppercase, etc.)
    
- Declare indexed and associative arrays
    
- Control variable scope (local/global)
    
- Display variable definitions and attributes
    

It affects **only the current shell or function scope**.

* * *

## 2\. Basic Syntax

```bash
typeset [OPTION] NAME[=VALUE]...
```

* * *

## 3\. `typeset` vs `declare`

In **Bash**:

- `typeset` and `declare` are **functionally identical**
    
- `declare` is preferred in scripts
    
- `typeset` exists for compatibility with other shells
    

```bash
typeset VAR=hello
declare VAR=hello
```

* * *

## 4\. Declare a Simple Variable

```bash
typeset VAR=hello
echo $VAR
```

Equivalent to:

```bash
VAR=hello
```

* * *

## 5\. Declare Read-Only Variables

```bash
typeset -r CONST=100
```

Attempting modification:

```bash
CONST=200   # error
```

* * *

## 6\. Declare Integer Variables

```bash
typeset -i COUNT=10
COUNT=COUNT+5
echo $COUNT   # 15
```

Arithmetic expressions are evaluated automatically.

* * *

## 7\. Uppercase and Lowercase Attributes

### Force lowercase

```bash
typeset -l name="HELLO"
echo $name   # hello
```

### Force uppercase

```bash
typeset -u city="kathmandu"
echo $city   # KATHMANDU
```

* * *

## 8\. Declare Indexed Arrays

```bash
typeset -a arr
arr=(one two three)
echo ${arr[2]}   # three
```

* * *

## 9\. Declare Associative Arrays (Bash 4+)

```bash
typeset -A map
map[user]=sushil
map[shell]=bash

echo ${map[user]}
```

* * *

## 10\. Local Variables in Functions

```bash
myfunc() {
  typeset local_var="inside"
  echo $local_var
}

myfunc
echo $local_var   # empty
```

`typeset` behaves like `local` inside functions.

* * *

## 11\. Export Variables Using `typeset`

```bash
typeset -x VAR=hello
```

Equivalent to:

```bash
export VAR=hello
```

* * *

## 12\. Display Variables and Attributes

### Show all variables

```bash
typeset
```

### Show exported variables

```bash
typeset -x
```

### Show functions

```bash
typeset -f
```

* * *

## 13\. Inspect Variable Definition

```bash
typeset -p VAR
```

Example output:

```bash
typeset -x VAR="hello"
```

* * *

## 14\. Common `typeset` Options

| Option | Meaning |
| --- | --- |
| `-a` | Indexed array |
| `-A` | Associative array |
| `-i` | Integer |
| `-r` | Read-only |
| `-x` | Export |
| `-l` | Lowercase |
| `-u` | Uppercase |
| `-f` | Functions |
| `-p` | Print attributes |

* * *

## 15\. Using `typeset` in Scripts

```bash
#!/usr/bin/env bash
typeset -r APP="demo"
typeset -i RETRY=3
```

* * *

## 16\. `typeset` vs `local`

| Feature | `typeset` | `local` |
| --- | --- | --- |
| Global scope | ✅ Yes | ❌ No |
| Function scope | ✅ Yes | ✅ Yes |
| Attributes | ✅ Yes | ❌ No |

* * *

## 17\. `typeset` vs `export`

| Feature | `typeset -x` | `export` |
| --- | --- | --- |
| Export variable | ✅ Yes | ✅ Yes |
| Attributes | ✅ Yes | ❌ No |
| POSIX | ❌ No | ✅ Yes |

* * *

## 18\. Shell Compatibility

| Shell | Support |
| --- | --- |
| bash | ✅ Yes |
| zsh | ✅ Yes |
| ksh | ✅ Yes |
| sh (POSIX) | ❌ No |

* * *

## 19\. Common Mistakes

❌ Using `typeset` in `/bin/sh`

❌ Expecting portability across shells

❌ Using associative arrays in Bash < 4

* * *

## 20\. Security Considerations

- Exporting variables exposes them to child processes
    
- `typeset -x` may leak secrets
    
- Use readonly attributes for safety
    

* * *

## 21\. Useful One-Liners

```bash
typeset -p | grep PATH
```

```bash
typeset -a files=(*)
```

```bash
typeset -i total=0
```

* * *

## 22\. POSIX Notes

- `typeset` is **not POSIX-compliant**
    
- Use only in Bash/ksh/zsh scripts
    
- Prefer `declare` in Bash scripts
    

* * *

## 23\. Summary

- `typeset` is a powerful variable declaration tool
    
- Equivalent to `declare` in Bash
    
- Supports attributes, arrays, and scope control
    
- Best for advanced shell scripting
    

* * *

* * *

&nbsp;
