* * *

**Processes:** `ps`, `top`, `htop`, `atop`, `kill`, `pkill`, `killall`, `nice`, `renice`

* * *

* * *

# Linux `ps` Command

The `ps` (**process status**) command is used to display information about **active processes** running on a Linux system. Unlike `top` or `htop`, `ps` provides a **snapshot** of processes at the moment it is run.

* * *

## 1\. Basic Syntax

```bash
ps [OPTIONS]
```

Options can follow **three styles**:

- **UNIX style**: `ps aux`
    
- **BSD style**: `ps ax`
    
- **GNU style**: `ps -ef`
    

You can mix them, but it's best to be consistent.

* * *

## 2\. Most Commonly Used `ps` Commands

### 2.1 Show Processes for Current Shell

```bash
ps
```

Output fields:

- `PID` – Process ID
    
- `TTY` – Terminal
    
- `TIME` – CPU time
    
- `CMD` – Command
    

* * *

### 2.2 Show All Processes (BSD Style)

```bash
ps aux
```

Field meanings:

- `a` – processes from all users
    
- `u` – user-oriented format
    
- `x` – processes without terminal
    

Common columns:

- `USER`
    
- `PID`
    
- `%CPU`
    
- `%MEM`
    
- `VSZ` (Virtual memory)
    
- `RSS` (Resident memory)
    
- `STAT`
    
- `START`
    
- `TIME`
    
- `COMMAND`
    

* * *

### 2.3 Show All Processes (UNIX/GNU Style)

```bash
ps -ef
```

Columns:

- `UID`
    
- `PID`
    
- `PPID` (Parent PID)
    
- `C` (CPU usage)
    
- `STIME` (Start time)
    
- `TTY`
    
- `TIME`
    
- `CMD`
    

* * *

## 3\. Understanding Process States (`STAT` Column)

| Code | Meaning |
| --- | --- |
| R   | Running |
| S   | Sleeping |
| D   | Uninterruptible sleep (I/O) |
| T   | Stopped |
| Z   | Zombie |
| <   | High priority |
| N   | Low priority |
| s   | Session leader |
| +   | Foreground process |

Example:

```bash
ps aux | grep Z
```

* * *

## 4\. Filtering and Searching Processes

### 4.1 Find a Process by Name

```bash
ps aux | grep nginx
```

Better (avoids grep itself):

```bash
pgrep -a nginx
```

* * *

### 4.2 Show Process by PID

```bash
ps -p 1234
```

With custom output:

```bash
ps -p 1234 -o pid,ppid,cmd,%cpu,%mem
```

* * *

### 4.3 Show Processes by User

```bash
ps -u root
```

Or BSD style:

```bash
ps aux | grep '^root'
```

* * *

## 5\. Custom Output Formatting (`-o` option)

### 5.1 Custom Columns

```bash
ps -eo pid,user,ppid,cmd,%mem,%cpu --sort=-%cpu
```

Common fields:

- `pid`
    
- `ppid`
    
- `user`
    
- `cmd`
    
- `%cpu`
    
- `%mem`
    
- `etime` (elapsed time)
    
- `lstart` (full start time)
    

* * *

### 5.2 Show Full Command Path

```bash
ps -eo pid,args
```

* * *

## 6\. Sorting Output

### 6.1 Sort by CPU Usage

```bash
ps aux --sort=-%cpu
```

### 6.2 Sort by Memory Usage

```bash
ps aux --sort=-%mem
```

### 6.3 Sort by Start Time

```bash
ps -eo pid,lstart,cmd --sort=lstart
```

* * *

## 7\. Process Tree (Parent–Child View)

### 7.1 Tree View

```bash
ps -ejH
```

Or:

```bash
ps axjf
```

### 7.2 Tree for a Specific PID

```bash
ps -o pid,ppid,cmd --forest -p 1
```

* * *

## 8\. Long and Detailed Formats

### 8.1 Very Detailed View

```bash
ps -eLf
```

Shows threads (`LWP` column).

* * *

### 8.2 Show Threads for a Process

```bash
ps -T -p 1234
```

* * *

## 9\. Real‑World Use Cases

### 9.1 Find High CPU Processes

```bash
ps aux --sort=-%cpu | head
```

### 9.2 Find High Memory Processes

```bash
ps aux --sort=-%mem | head
```

### 9.3 Check If a Service Is Running

```bash
ps -ef | grep sshd
```

* * *

## 10\. Combining `ps` with Other Commands

### 10.1 Kill a Process

```bash
kill $(ps aux | grep myapp | awk '{print $2}')
```

### 10.2 Count Running Processes

```bash
ps -e --no-headers | wc -l
```

* * *

## 11\. Differences Between `ps`, `top`, and `htop`

| Command | Type | Refresh |
| --- | --- | --- |
| ps  | Snapshot | No  |
| top | Interactive | Yes |
| htop | Enhanced interactive | Yes |

* * *

## 12\. Common Mistakes

- Forgetting `x` → missing background processes
    
- Using `grep` without excluding itself
    
- Mixing incompatible options
    

* * *

## 13\. Quick Cheat Sheet

```bash
ps
ps aux
ps -ef
ps -u username
ps -p PID
ps -eo pid,cmd,%cpu,%mem
ps aux --sort=-%cpu
ps axjf
```

* * *

## 14\. Summary

- `ps` shows **process snapshots**
    
- BSD style (`ps aux`) is most popular
    
- `-o` and `--sort` make `ps` extremely powerful
    
- Best paired with `grep`, `awk`, `kill`
    

* * *

* * *

# Linux `top` Command 

The `top` command is an **interactive, real-time process monitor** in Linux. It shows system performance, CPU and memory usage, and running processes, updating continuously.

Unlike `ps` (snapshot), `top` provides **live system monitoring**.

* * *

## 1\. Basic Syntax

```bash
top [OPTIONS]
```

Run without options to start interactive mode:

```bash
top
```

* * *

## 2\. Understanding the `top` Screen Layout

The `top` display has **two main sections**:

1.  **Summary Area (Top Section)**
    
2.  **Task/Process List (Bottom Section)**
    

* * *

## 3\. Summary Area Explained

Example header:

```
top - 14:20:11 up 5 days,  3:12,  2 users,  load average: 0.45, 0.30, 0.25
Tasks: 215 total,   1 running, 214 sleeping,   0 stopped,   0 zombie
%Cpu(s):  3.2 us,  1.1 sy,  0.0 ni, 95.3 id,  0.2 wa,  0.0 hi,  0.2 si,  0.0 st
MiB Mem :  15942.0 total,  2345.5 free,  6543.2 used,  7053.3 buff/cache
MiB Swap:   4096.0 total,  4096.0 free,     0.0 used
```

### 3.1 System Uptime & Load Average

- **Load average**: `1, 5, 15` minute system load
    
- Ideal load ≈ number of CPU cores
    

* * *

### 3.2 Tasks (Processes)

- `total` – total processes
    
- `running` – currently executing
    
- `sleeping` – idle
    
- `stopped` – stopped by signal
    
- `zombie` – dead but not cleaned
    

* * *

### 3.3 CPU Usage Breakdown

| Field | Meaning |
| --- | --- |
| us  | User processes |
| sy  | Kernel processes |
| ni  | Nice (low priority) |
| id  | Idle |
| wa  | I/O wait |
| hi  | Hardware interrupt |
| si  | Software interrupt |
| st  | Steal time (VMs) |

* * *

### 3.4 Memory Usage

- **used** – memory in use
    
- **free** – unused memory
    
- **buff/cache** – cached data (reclaimable)
    

Linux uses free memory aggressively for caching.

* * *

## 4\. Process List Columns Explained

Common columns:

| Column | Meaning |
| --- | --- |
| PID | Process ID |
| USER | Owner |
| PR  | Priority |
| NI  | Nice value |
| VIRT | Virtual memory |
| RES | Resident memory |
| SHR | Shared memory |
| S   | State |
| %CPU | CPU usage |
| %MEM | Memory usage |
| TIME+ | CPU time |
| COMMAND | Command name |

* * *

## 5\. Interactive Keyboard Commands (MOST IMPORTANT)

### 5.1 Help

```text
h or ?
```

* * *

### 5.2 Quit `top`

```text
q
```

* * *

### 5.3 Sort Processes

| Key | Sort By |
| --- | --- |
| P   | CPU usage |
| M   | Memory usage |
| T   | Running time |
| N   | PID |

* * *

### 5.4 Kill a Process

```text
k
```

Then enter PID and signal (default 15).

* * *

### 5.5 Change Refresh Delay

```text
d
```

Enter seconds (e.g., `1` for 1s refresh).

* * *

### 5.6 Toggle Display Options

| Key | Action |
| --- | --- |
| c   | Full command path |
| 1   | Show all CPU cores |
| t   | CPU summary |
| m   | Memory summary |
| z   | Color toggle |
| x   | Highlight sort column |
| y   | Highlight running tasks |

* * *

## 6\. Running `top` in Batch Mode (Non‑Interactive)

Useful for logging or scripts.

```bash
top -b -n 1
```

- `-b` → batch mode
    
- `-n 1` → run once
    

* * *

## 7\. Filter Processes in `top`

### 7.1 Show Only One User

```bash
top -u root
```

* * *

### 7.2 Filter by PID (Interactive)

Press:

```text
p
```

Then enter PID(s).

* * *

## 8\. Thread View

### 8.1 Show Threads

```bash
top -H
```

Toggle in interactive mode:

```text
H
```

* * *

## 9\. CPU Affinity & Per-Core View

Show each CPU core:

```text
1
```

Useful on multi-core systems.

* * *

## 10\. Saving `top` Configuration

After customizing view:

```text
W
```

Saves settings to:

```text
~/.toprc
```

* * *

## 11\. Advanced Usage Examples

### 11.1 Find CPU Hogs

```bash
top -o %CPU
```

* * *

### 11.2 Find Memory Hogs

```bash
top -o %MEM
```

* * *

### 11.3 Monitor a Specific Process

```bash
top -p 1234
```

* * *

### 11.4 Continuous Logging

```bash
top -b -d 5 -n 10 >> top.log
```

* * *

## 12\. `top` vs `htop` vs `ps`

| Tool | Type | Interactive | Best Use |
| --- | --- | --- | --- |
| ps  | Snapshot | No  | Scripting |
| top | Real-time | Yes | Monitoring |
| htop | Enhanced | Yes | Ease of use |

* * *

## 13\. Common Mistakes

- Misunderstanding cached memory as "used"
    
- Ignoring load average vs CPU cores
    
- Killing wrong PID
    

* * *

## 14\. Quick `top` Cheat Sheet

```text
top
q  → quit
k  → kill process
P  → sort by CPU
M  → sort by memory
1  → per-CPU view
c  → full command
d  → delay
H  → threads
W  → save config
```

* * *

## 15\. Summary

- `top` provides **live system monitoring**
    
- Interactive keys are the real power
    
- Ideal for **performance debugging & system health**
    
- Complements `ps`, not replaces it
    

* * *

* * *

# Linux `htop` Command

The `htop` command is an **interactive, enhanced process viewer** for Linux. It is a more user‑friendly and powerful alternative to `top`, offering colorized output, mouse support, and easier process management.

`htop` provides **real‑time system monitoring** with an intuitive interface.

* * *

## 1\. What Is `htop`?

- Interactive process viewer
    
- Real‑time CPU, memory, and swap monitoring
    
- Easier process killing and priority changes
    
- Visual CPU core usage bars
    
- Scrollable process list
    

* * *

## 2\. Installing `htop`

Most Linux distributions do not install `htop` by default.

### Debian / Ubuntu

```bash
sudo apt install htop
```

### RHEL / CentOS / Rocky / Alma

```bash
sudo dnf install htop
```

### Arch Linux

```bash
sudo pacman -S htop
```

* * *

## 3\. Basic Usage

Start `htop`:

```bash
htop
```

Quit:

```text
q
```

* * *

## 4\. Understanding the `htop` Interface

The screen is divided into **three main areas**:

1.  **Header (Meters)**
    
2.  **Process List**
    
3.  **Footer (Function Keys)**
    

* * *

## 5\. Header (Meters) Explained

### 5.1 CPU Usage

- Each CPU core is shown separately
    
- Colors indicate:
    
    - Green → user processes
        
    - Red → kernel processes
        
    - Blue → low priority (nice)
        

* * *

### 5.2 Memory & Swap

- **Mem**: RAM usage
    
- **Swp**: Swap usage
    

Linux aggressively uses memory for cache—this is normal.

* * *

### 5.3 Load Average & Uptime

- Load average shows system load (1, 5, 15 min)
    
- Uptime shows how long the system has been running
    

* * *

## 6\. Process List Columns

Common columns:

| Column | Meaning |
| --- | --- |
| PID | Process ID |
| USER | Owner |
| PRI | Priority |
| NI  | Nice value |
| VIRT | Virtual memory |
| RES | Resident memory |
| SHR | Shared memory |
| S   | State |
| CPU% | CPU usage |
| MEM% | Memory usage |
| TIME+ | CPU time |
| Command | Command |

* * *

## 7\. Keyboard Shortcuts (Very Important)

### 7.1 Function Keys

| Key | Action |
| --- | --- |
| F1  | Help |
| F2  | Setup / Configuration |
| F3  | Search |
| F4  | Filter |
| F5  | Tree view |
| F6  | Sort by |
| F7  | Decrease priority (nice +) |
| F8  | Increase priority (nice -) |
| F9  | Kill process |
| F10 | Quit |

* * *

## 8\. Searching & Filtering

### 8.1 Search for a Process

```text
F3
```

Type process name and press Enter.

* * *

### 8.2 Filter Processes

```text
F4
```

Example filter:

```text
nginx
```

* * *

## 9\. Sorting Processes

Press:

```text
F6
```

Sort by:

- CPU%
    
- MEM%
    
- TIME+
    
- PID
    
- USER
    

* * *

## 10\. Tree View (Parent–Child Processes)

Toggle tree view:

```text
F5
```

Shows process hierarchy clearly.

* * *

## 11\. Killing Processes

1.  Select a process
    
2.  Press:
    

```text
F9
```

3.  Choose signal (default `SIGTERM`)

Common signals:

- `15` → SIGTERM (safe)
    
- `9` → SIGKILL (force)
    

* * *

## 12\. Changing Process Priority (Nice)

- Increase priority:

```text
F8
```

- Decrease priority:

```text
F7
```

Root privileges may be required.

* * *

## 13\. Mouse Support

`htop` supports mouse interactions:

- Click to select processes
    
- Scroll to navigate
    
- Click meters and columns
    

* * *

## 14\. Setup & Customization (`F2`)

### 14.1 Customize Columns

Add/remove:

- CPU%
    
- MEM%
    
- I/O
    
- Threads
    

* * *

### 14.2 Customize Meters

You can add:

- CPU average
    
- Memory bars
    
- Disk I/O
    
- Network I/O
    

* * *

### 14.3 Color Schemes

Choose different color themes for better readability.

* * *

## 15\. Running `htop` for a Specific User

```bash
htop -u root
```

* * *

## 16\. Monitoring Specific PIDs

```bash
htop -p 1234,5678
```

* * *

## 17\. Thread View

Toggle threads:

```text
H
```

* * *

## 18\. `htop` vs `top` vs `ps`

| Tool | Interactive | Ease | Best Use |
| --- | --- | --- | --- |
| ps  | No  | Medium | Scripting |
| top | Yes | Medium | Live monitoring |
| htop | Yes | Easy | Visual management |

* * *

## 19\. Common Mistakes

- Killing system processes accidentally
    
- Misreading cached memory as real usage
    
- Running as root unnecessarily
    

* * *

## 20\. Quick `htop` Cheat Sheet

```text
htop
F3 → search
F4 → filter
F5 → tree view
F6 → sort
F7/F8 → nice
F9 → kill
F10 → quit
```

* * *

## 21\. Summary

- `htop` is the **most user‑friendly process monitor**
    
- Ideal for **daily sysadmin and debugging work**
    
- Faster and safer than `top`
    
- Excellent complement to `ps` and `top`
    

* * *

* * *

# Linux `atop` Command

`atop` is an **advanced system and process monitoring tool** for Linux. Unlike `top` and `htop`, `atop` provides:

- Historical logging of system and process activity
    
- Detailed per-process CPU, memory, disk, and network usage
    
- Ability to analyze system performance over time
    

* * *

## 1\. Installing `atop`

### Debian / Ubuntu

```bash
sudo apt install atop
```

### RHEL / CentOS / Rocky / Alma

```bash
sudo dnf install atop
```

### Arch Linux

```bash
sudo pacman -S atop
```

* * *

## 2\. Starting `atop`

Run interactively:

```bash
atop
```

- Press `q` to quit
    
- Updates every 10 seconds by default
    

* * *

## 3\. `atop` Screen Layout

The `atop` screen shows:

1.  **Summary (Top Section)**
    
2.  **Process List (Bottom Section)**
    

### 3.1 Summary Metrics

- **CPU**: user, system, nice, idle, wait, steal, interrupt
    
- **Memory**: total, used, free, cache, swap
    
- **Disk**: read/write rates
    
- **Network**: sent/received bytes, connections
    

* * *

## 4\. Process View

`atop` shows **all processes** (even short-lived ones) with metrics:

- `PID` – Process ID
    
- `PR` – Priority
    
- `NLWP` – Number of threads
    
- `CPU%` – CPU usage
    
- `MEM%` – Memory usage
    
- `DSK%` – Disk usage
    
- `NET%` – Network usage
    
- `Command` – Command name
    

* * *

## 5\. Interactive Keyboard Commands

| Key | Action |
| --- | --- |
| t   | Toggle threads display |
| m   | Toggle memory statistics per process |
| d   | Toggle disk statistics per process |
| n   | Toggle network statistics per process |
| c   | Toggle command line view |
| u   | Show process for specific user |
| p   | Show specific PID |
| g   | Go to a specific record (historical log) |
| q   | Quit |

* * *

## 6\. Logging Mode

`atop` can **log system performance** for later analysis.

### 6.1 Start Logging

```bash
sudo atop -w /var/log/atop.log 60 10
```

- `-w` → write to log file
    
- `60` → interval in seconds
    
- `10` → number of snapshots
    

### 6.2 Read Logs

```bash
sudo atop -r /var/log/atop.log
```

Navigate snapshots with `t` (time) key.

* * *

## 7\. Filtering Processes

### 7.1 By User

```text
u
```

Then type username.

### 7.2 By PID

```text
p
```

Then type PID.

* * *

## 8\. Sorting Processes

- Default sorts by CPU usage
    
- Interactive toggles can sort by memory, disk, or network usage
    
- Helps identify **resource hogs**
    

* * *

## 9\. Advanced Metrics

### 9.1 Disk I/O Per Process

```text
d
```

Shows read/write rates for each process.

### 9.2 Network Usage Per Process

```text
n
```

Shows bytes sent/received for each process.

### 9.3 Memory Usage Per Process

```text
m
```

Shows detailed memory usage per process.

* * *

## 10\. Per-Thread View

```text
t
```

Shows threads for processes (useful for multi-threaded applications).

* * *

## 11\. Historical Analysis

- `atop` logs can be saved and analyzed later
    
- Helps identify **transient spikes in CPU, memory, disk, or network usage**
    
- Example:
    

```bash
sudo atop -r /var/log/atop.log
```

Navigate snapshots with `t` and `TAB` keys.

* * *

## 12\. Examples

### 12.1 Show Current Processes

```bash
atop
```

### 12.2 Log System Activity Every 60s, 10 Snapshots

```bash
sudo atop -w /var/log/atop.log 60 10
```

### 12.3 Read Historical Log

```bash
sudo atop -r /var/log/atop.log
```

### 12.4 Monitor Specific User

```text
u → username
```

### 12.5 Monitor Specific PID

```text
p → PID
```

* * *

## 13\. `atop` vs `top` vs `htop`

| Tool | Interactive | Historical | Metrics | Best Use |
| --- | --- | --- | --- | --- |
| ps  | No  | No  | Basic | Scripting |
| top | Yes | No  | CPU/Mem | Real-time monitoring |
| htop | Yes | No  | CPU/Mem | Interactive visualization |
| atop | Yes | Yes | CPU/Mem/Disk/Net | Advanced monitoring & logging |

* * *

## 14\. Common Mistakes

- Not running as root → cannot see all metrics
    
- Misreading cache as memory usage
    
- Ignoring disk/network columns when analyzing performance spikes
    

* * *

## 15\. Quick `atop` Cheat Sheet

```text
atop          → start interactive monitoring
q             → quit
u             → filter by user
p             → filter by PID
t             → toggle threads
m             → toggle memory
d             → toggle disk I/O
n             → toggle network
c             → toggle command line
sudo atop -w logfile 60 10  → logging mode
sudo atop -r logfile       → read logs
```

* * *

## 16\. Summary

- `atop` is **best for advanced performance monitoring**
    
- Offers **historical logging** and **per-resource analysis**
    
- Complements `top` and `htop` by providing **detailed disk and network insights**
    
- Ideal for **sysadmins and performance engineers**
    

* * *

* * *

# Linux `kill` Command 

The `kill` command in Linux is used to **send signals to processes**, most commonly to terminate them. Despite its name, `kill` can send **any signal**, not just `SIGKILL`.

* * *

## 1\. Basic Syntax

```bash
kill [OPTIONS] <PID>...
```

- `PID` → Process ID(s) to send the signal to
    
- If no signal is specified, the default is `SIGTERM` (signal 15)
    

Alternative syntax:

```bash
kill -s <SIGNAL> <PID>
kill -<SIGNAL_NUMBER> <PID>
```

* * *

## 2\. Common Signals

| Signal | Number | Description |
| --- | --- | --- |
| SIGTERM | 15  | Terminate process gracefully (default) |
| SIGKILL | 9   | Kill immediately (cannot be caught) |
| SIGINT | 2   | Interrupt (like Ctrl+C) |
| SIGHUP | 1   | Hangup (reload configuration) |
| SIGSTOP | 19  | Stop process (cannot be ignored) |
| SIGCONT | 18  | Continue stopped process |

List all signals:

```bash
kill -l
```

* * *

## 3\. Examples

### 3.1 Kill a Process Gracefully

```bash
kill 1234
```

- Sends `SIGTERM` to process with PID 1234

### 3.2 Force Kill a Process

```bash
kill -9 1234
```

- Sends `SIGKILL` (cannot be trapped)

### 3.3 Kill Multiple Processes

```bash
kill 1234 2345 3456
```

### 3.4 Kill by Signal Name

```bash
kill -s SIGINT 1234
```

- Sends `SIGINT` signal

### 3.5 Kill by Signal Number

```bash
kill -15 1234
```

- Sends `SIGTERM` explicitly

### 3.6 Kill All Processes by Name (Use with Caution)

```bash
pkill firefox
```

- `pkill` kills by process name

Or with `killall`:

```bash
killall firefox
```

### 3.7 Kill Processes by User

```bash
pkill -u username
```

- Kills all processes belonging to `username`

* * *

## 4\. Combining `kill` with `ps`

### 4.1 Find and Kill a Process by Name

```bash
ps aux | grep myapp
kill 2345
```

- Identify PID first, then kill

### 4.2 Kill All Matching Processes

```bash
ps aux | grep myapp | awk '{print $2}' | xargs kill
```

- Sends default signal to all matching PIDs

* * *

## 5\. Stopping and Resuming Processes

### 5.1 Stop a Process

```bash
kill -STOP 1234
```

- Pauses process execution

### 5.2 Resume a Stopped Process

```bash
kill -CONT 1234
```

- Continues process execution

* * *

## 6\. SIGHUP for Reloading Configuration

Many daemons reload configuration on `SIGHUP`:

```bash
kill -HUP 1234
```

- Example: reload nginx without stopping it

```bash
sudo kill -HUP $(pidof nginx)
```

* * *

## 7\. Notes and Precautions

- Always try `SIGTERM` first; `SIGKILL` can cause data loss
    
- Check process ownership: you can only kill processes you own or root
    
- Use `ps`, `top`, or `htop` to identify the correct PID
    
- Killing system-critical processes may crash your system
    

* * *

## 8\. Quick Reference

```text
kill <PID>          → default SIGTERM
kill -9 <PID>       → force kill (SIGKILL)
kill -s SIGINT <PID> → send SIGINT
killall <name>      → kill all processes by name
pkill <name>        → kill by name
pkill -u username   → kill processes by user
kill -l             → list all signals
kill -STOP <PID>    → pause process
kill -CONT <PID>    → resume process
```

* * *

## 9\. Summary

- `kill` is **essential for process management**
    
- Can send **any signal**, not just terminate
    
- Combine with `ps`, `top`, `htop` for safe and effective use
    
- Use `pkill` or `killall` for convenience when dealing with multiple processes
    

* * *

* * *

# Linux `pkill` Command

The `pkill` command is used to **send signals to processes by name or other attributes**, rather than by PID. It is part of the **procps package** and is often more convenient than `kill` for terminating multiple processes.

* * *

## 1\. Basic Syntax

```bash
pkill [OPTIONS] <pattern>
```

- `<pattern>` → process name or pattern
    
- By default, sends `SIGTERM` signal
    

Alternative form to send a specific signal:

```bash
pkill -SIGNAL <pattern>
pkill -s <SIGNAL> <pattern>
```

* * *

## 2\. Common Options

| Option | Description |
| --- | --- |
| \-u | Match only processes owned by a specific user |
| \-t | Match processes running on a specific terminal |
| \-f | Match against full command line (not just process name) |
| \-n | Match only the newest process |
| \-o | Match only the oldest process |
| \-signal | Specify signal (e.g., `-9` for SIGKILL) |
| \-l | List all signals |

* * *

## 3\. Signals

Common signals:

- `SIGTERM` (15) – default, graceful termination
    
- `SIGKILL` (9) – force kill
    
- `SIGHUP` (1) – reload configuration
    
- `SIGSTOP` – pause process
    
- `SIGCONT` – resume process
    

List all signals:

```bash
pkill -l
```

* * *

## 4\. Examples

### 4.1 Kill All Processes by Name

```bash
pkill firefox
```

- Kills all processes with name `firefox`

### 4.2 Force Kill by Name

```bash
pkill -9 firefox
```

- Sends `SIGKILL` to all matching processes

### 4.3 Kill Processes by User

```bash
pkill -u sushil myapp
```

- Kills `myapp` processes owned by user `sushil`

### 4.4 Kill Processes by Terminal

```bash
pkill -t pts/1
```

- Kills all processes running on terminal `pts/1`

### 4.5 Match Full Command Line

```bash
pkill -f 'python script.py'
```

- Kills process where the **full command line** matches

### 4.6 Kill Only Newest Process

```bash
pkill -n firefox
```

- Only kills the newest process matching `firefox`

### 4.7 Kill Only Oldest Process

```bash
pkill -o firefox
```

- Only kills the oldest process matching `firefox`

### 4.8 Dry Run (Show Matching Processes Without Killing)

```bash
pgrep firefox
```

- Lists PIDs without killing
    
- Can combine: `pgrep firefox | xargs -p kill` (manual confirmation)
    

* * *

## 5\. Combining `pkill` with Other Commands

### 5.1 Check Before Killing

```bash
pgrep -a myapp
```

- Shows process name and PID

### 5.2 Kill Multiple Process Names

```bash
pkill -f 'app1|app2|app3'
```

- Kills all processes whose full command line matches any of the patterns

* * *

## 6\. Notes and Precautions

- Use `-f` carefully; it can match more than intended
    
- Only kill processes you own or root
    
- Always check `pgrep` output before using `pkill`
    
- Combine with `top` or `htop` for process inspection
    

* * *

## 7\. Quick Reference

```text
pkill <name>           → default SIGTERM
pkill -9 <name>        → force kill (SIGKILL)
pkill -u username <name> → kill user processes
pkill -t pts/1 <name>  → kill processes on a terminal
pkill -f '<pattern>'   → match full command line
pkill -n <name>        → kill newest
pkill -o <name>        → kill oldest
pgrep <name>           → list matching PIDs
```

* * *

## 8\. Summary

- `pkill` is a **powerful alternative to `kill`** for processes by name, user, or attributes
    
- Default signal is `SIGTERM`; can send any signal
    
- Safer and quicker than manually identifying PIDs
    
- Best combined with `pgrep`, `top`, or `htop` for process inspection
    

* * *

* * *

# Linux `killall` Command 

The `killall` command in Linux is used to **terminate processes by name**. It is similar to `pkill`, but behaves slightly differently depending on the system. It sends a signal (default `SIGTERM`) to **all processes matching a given name**.

* * *

## 1\. Basic Syntax

```bash
killall [OPTIONS] <process_name>
```

- `<process_name>` → name of the process to kill
    
- By default, sends `SIGTERM`
    
- Can specify other signals with `-s` or `-SIGNAL`
    

Alternative signal syntax:

```bash
killall -s SIGKILL <process_name>
killall -9 <process_name>
```

* * *

## 2\. Common Options

| Option | Description |
| --- | --- |
| \-i | Interactive mode (confirm each kill) |
| \-v | Verbose (show what is being killed) |
| \-q | Quiet (no output) |
| \-u | Kill only processes owned by a user |
| \-s | Specify a signal (e.g., SIGKILL, SIGTERM) |
| \-r | Match process name using regular expressions |
| \-w | Wait for all killed processes to die |
| \-V | Show version information |

* * *

## 3\. Signals

- Default: `SIGTERM` (15) – graceful termination
    
- Common signals:
    
    - `SIGKILL` (9) – force kill
        
    - `SIGINT` (2) – interrupt
        
    - `SIGHUP` (1) – reload configuration
        
    - `SIGSTOP` – pause process
        
    - `SIGCONT` – resume process
        

List all signals:

```bash
killall -l
```

* * *

## 4\. Examples

### 4.1 Kill All Processes by Name

```bash
killall firefox
```

- Sends `SIGTERM` to all `firefox` processes

### 4.2 Force Kill by Name

```bash
killall -9 firefox
```

- Sends `SIGKILL` to all `firefox` processes

### 4.3 Interactive Kill

```bash
killall -i firefox
```

- Confirms before killing each process

### 4.4 Verbose Mode

```bash
killall -v firefox
```

- Shows which processes were terminated

### 4.5 Kill Processes Owned by a User

```bash
killall -u sushil myapp
```

- Kills `myapp` processes owned by user `sushil`

### 4.6 Kill by Regular Expression

```bash
killall -r 'firefox|chrome'
```

- Kills all processes matching the regex `firefox` or `chrome`

### 4.7 Wait for Processes to Terminate

```bash
killall -w firefox
```

- Waits until all `firefox` processes have terminated before returning

* * *

## 5\. Notes and Precautions

- Be careful: `killall` may kill **more processes than intended** if the name is generic
    
- Ensure correct process name and user
    
- Always check with `pgrep <name>` or `ps aux | grep <name>` first
    
- System-critical processes (like `init`, `systemd`) should never be killed
    

* * *

## 6\. Quick Reference

```text
killall <name>           → default SIGTERM
killall -9 <name>        → force kill (SIGKILL)
killall -i <name>        → interactive confirmation
killall -v <name>        → verbose output
killall -u username <name> → kill user-owned processes
killall -r '<regex>'     → kill by regular expression
killall -w <name>        → wait for termination
killall -l                → list all signals
```

* * *

## 7\. Summary

- `killall` is a **convenient way to terminate multiple processes by name**
    
- Default signal is `SIGTERM`; can use `-s` or `-SIGNAL` for other signals
    
- Similar to `pkill` but with slightly different options and behavior
    
- Combine with `pgrep` or `top` for safer operation
    

* * *

* * *

# Linux `nice` Command

The `nice` command in Linux is used to **start a process with a modified scheduling priority**. Processes with higher “niceness” values run with **lower priority**, while lower values run with **higher priority**.

It works in conjunction with `renice` for adjusting priorities of running processes.

* * *

## 1\. Basic Syntax

```bash
nice [OPTION] [COMMAND [ARG]...]
```

- `[COMMAND]` → command to run
    
- Default niceness: 10 (varies by system)
    
- Range: `-20` (highest priority) to `19` (lowest priority)
    

Check current niceness:

```bash
nice -n 0 command
```

* * *

## 2\. Understanding Niceness

- **Niceness**: determines **CPU scheduling priority**
    
- **Lower niceness** → higher priority → more CPU time
    
- **Higher niceness** → lower priority → less CPU time
    
- Only root can set negative niceness values (higher priority)
    

View niceness of running processes:

```bash
ps -o pid,ni,cmd -p <PID>
```

* * *

## 3\. Basic Examples

### 3.1 Run Command with Default Niceness

```bash
nice gzip largefile
```

- Default niceness is applied (usually 10)

### 3.2 Run Command with Specific Niceness

```bash
nice -n 5 gzip largefile
```

- Sets niceness to 5 (lower priority than default)

### 3.3 Run Command with High Priority (Negative Niceness)

```bash
sudo nice -n -10 gzip largefile
```

- Requires root privileges
    
- Higher priority, more CPU allocation
    

### 3.4 Check Niceness of Running Processes

```bash
ps -eo pid,ni,cmd | grep gzip
```

- Shows niceness (`NI`) of the process

* * *

## 4\. Using `nice` with Other Commands

### 4.1 Run CPU-Intensive Task with Low Priority

```bash
nice -n 15 ./heavy_script.sh
```

- Lets other processes run smoothly

### 4.2 Combine with `time` Command

```bash
time nice -n 10 ./heavy_task.sh
```

- Measures execution time with niceness adjustment

### 4.3 Redirect Output

```bash
nice -n 10 ./script.sh > output.log
```

* * *

## 5\. Interaction with `renice`

- `nice` sets priority **at start**
    
- `renice` changes priority **of running processes**
    

```bash
sudo renice -n 5 -p <PID>
```

- Changes niceness of an existing process

* * *

## 6\. Practical Examples

### 6.1 Lower Priority Backup Task

```bash
nice -n 19 rsync -av /source /backup
```

- Runs backup in background with minimal CPU impact

### 6.2 Increase Priority for Critical Task

```bash
sudo nice -n -5 ./critical_job.sh
```

- Executes job faster by giving it higher CPU priority

### 6.3 Start Multiple Low-Priority Processes

```bash
for i in {1..5}; do nice -n 10 ./task$i.sh & done
```

- Runs tasks in background without hogging CPU

* * *

## 7\. Check Current Niceness

```bash
top
```

- Look at `NI` column

```bash
ps -eo pid,ni,cmd | grep myapp
```

- View niceness of specific process

* * *

## 8\. Notes and Precautions

- Niceness affects **CPU scheduling only**, not I/O or memory
    
- Only root can assign negative niceness (higher priority)
    
- Default niceness is usually 0 or 10 (depends on distro)
    
- Niceness is a **hint to the scheduler**, not a guarantee
    

* * *

## 9\. Quick Reference

```text
nice command            → start with default niceness
nice -n 10 command       → set niceness to 10
sudo nice -n -5 command  → higher priority
ps -o pid,ni,cmd         → check niceness of processes
renice -n 5 -p <PID>     → change niceness of running process
```

* * *

## 10\. Summary

- `nice` allows **CPU priority adjustment for processes**
    
- Higher niceness → lower priority, lower niceness → higher priority
    
- Ideal for **running background or critical tasks efficiently**
    
- Works in combination with `renice` for runtime adjustments
    

* * *

* * *

# Linux `renice` Command

The `renice` command in Linux is used to **change the priority (niceness) of running processes**. It works in conjunction with the `nice` command, which sets priority when starting a process.

* * *

## 1\. Basic Syntax

```bash
renice [OPTIONS] <niceness> -p <PID> [-u <user>] [-g <group>]
```

- `<niceness>` → new priority value (-20 to 19)
    
- `-p <PID>` → process ID(s)
    
- `-u <user>` → all processes of a user
    
- `-g <group>` → all processes of a group
    

* * *

## 2\. Understanding Niceness

- **Niceness** affects CPU scheduling priority
    
- Range: `-20` (highest priority) to `19` (lowest priority)
    
- Only root can assign negative niceness (higher priority)
    
- Default niceness for processes is usually 0 or 10 depending on system
    

* * *

## 3\. Basic Examples

### 3.1 Increase Priority of a Process

```bash
sudo renice -n -5 -p 1234
```

- Makes process 1234 higher priority (more CPU allocation)

### 3.2 Lower Priority of a Process

```bash
renice -n 10 -p 1234
```

- Makes process 1234 lower priority (less CPU allocation)
    
- No root required for positive niceness
    

### 3.3 Change Niceness of Multiple Processes

```bash
sudo renice -n 0 -p 1234 2345 3456
```

- Adjusts niceness of multiple PIDs simultaneously

* * *

## 4\. Change Niceness by User

```bash
sudo renice -n 5 -u sushil
```

- Changes niceness of all processes owned by user `sushil`

### 4.1 Check Niceness Before Changing

```bash
ps -u sushil -o pid,ni,cmd
```

- Lists processes with their current niceness

* * *

## 5\. Change Niceness by Group

```bash
sudo renice -n 10 -g developers
```

- Changes niceness of all processes belonging to group `developers`

* * *

## 6\. Combine with `top` or `htop`

- Identify PIDs:

```bash
top
```

- Adjust niceness:

```bash
sudo renice -n -10 -p <PID>
```

- Verify changes in `NI` column in `top` or `htop`

* * *

## 7\. Practical Examples

### 7.1 Increase Priority for Critical Job

```bash
sudo renice -n -10 -p 5678
```

- Critical job gets more CPU time

### 7.2 Decrease Priority for Background Task

```bash
renice -n 15 -p 8765
```

- Lets foreground tasks run smoothly

### 7.3 Change Niceness for All User Processes

```bash
sudo renice -n 5 -u sushil
```

- Adjust all user `sushil` processes at once

* * *

## 8\. Notes and Precautions

- Only root can **decrease niceness (increase priority)**
    
- Changing priority affects CPU scheduling only
    
- Use with caution on critical system processes
    
- Always check process ownership and PID before changing niceness
    

* * *

## 9\. Quick Reference

```text
renice -n <niceness> -p <PID>      → change niceness of a process
renice -n <niceness> -u <user>     → change all processes of a user
renice -n <niceness> -g <group>    → change all processes of a group
ps -o pid,ni,cmd -p <PID>          → check current niceness
sudo renice -n -5 -p <PID>         → increase priority
renice -n 15 -p <PID>              → lower priority
```

* * *

## 10\. Summary

- `renice` adjusts the **CPU priority of running processes**
    
- Works with `nice` to manage scheduling effectively
    
- Essential for optimizing system performance and resource allocation
    
- Ideal for sysadmins and performance tuning
    

* * *

* * *

&nbsp;
